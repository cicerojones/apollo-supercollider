* define synths and load samples
#+BEGIN_SRC clojure :results silent
  (def goldberg-slow (load-sample "/Users/b/Google Drive/Audio_uploads/wav-file-uploads/goldberg-slow-mono.wav"))

  (defsynth general-tgrains-synth [buffer 0 trate 1 dur-numerator 8 amp 0.8 centerpos 0]
    (let [trate trate
          dur (/ dur-numerator trate)
          clk (impulse:ar trate)
          centerpos centerpos]
      (out 0 (pan2 (t-grains:ar 1 clk buffer 1 centerpos dur 0 amp 2)))))

  (def gold (general-tgrains-synth 0))
#+END_SRC

* define refs
#+BEGIN_SRC clojure :results silent
;;; save "centerpos" values
  (def liked-values (atom []))

;;; use current-val to hold current 'centerpos' value
  (def current-val (atom 0))

;;; use cc knob to change high point of maprange destination value
  (def dst-hi (atom 0))

;;; determine trate value
  (def trate-ref (atom 1))

;;; determine dur-numerator for tgrains duration
  (def durnumerator-ref (atom 8))
#+END_SRC
* define utility functions
#+BEGIN_SRC clojure
  ;; hard codes in ref for "liked-values"
  (defn record-val [place]
    (swap! liked-values conj (deref place)))

(defn maprange [[a1 a2] [b1 b2] s]
	(+ b1 (/ (* (- s a1) (- b2 b1)) (- a2 a1))))

(defn round2
  "Round a double to the given precision (number of significant digits)"
  [precision d]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/round (* d factor)) factor)))

#+END_SRC
* define event handlers
** event handler pad and knob abstractions
#+BEGIN_SRC clojure :results silent
  (defn old-reset-knob [synth synth-param knob-number place midi-channel & {:keys [scale]
                                                                        :or {scale 1}}]
      (fn [{knob :note val :velocity chan :channel}]
        (if (= chan midi-channel)
          (cond (= knob knob-number)
                (do (reset! place (* val scale))
                    (ctl synth (keyword synth-param) (deref place))
                    (println (str synth-param knob-number " : ") (deref place)))))))

  (defn old-swap-pad [synth synth-param pad-number place swap-fn midi-channel]
      (fn [{pad :note val :velocity chan :channel}]
        (if (= chan midi-channel)
          (cond (= pad pad-number)
                (do (swap! place swap-fn)
                    (ctl synth (keyword synth-param) (deref place))
                    (println (str synth-param pad-number " : ") (deref place)))))))
#+END_SRC
** keyboard keys and transport event handlers (with scaling)
#+BEGIN_SRC clojure
;; determine "centerpos" based on MIDI keyboard notes
  (on-event [:midi :note-on]
            (fn [{note :note}]
              (let [val (deref current-val)]
                (do (reset! current-val (maprange [60 91] [0.0 @dst-hi] note))
                    (ctl gold :centerpos val)
                    (println (round2 val 2)))))
            ::set-current-val-scale-and-play)

;; save a "liked value" into storage with "record" button
;; return list of "liked values" with "play" button
  (on-event [:midi :control-change]
            (fn [{cc-channel :note vel :velocity}]
              (case vel
                127
                (case cc-channel 
                  18 (record-val current-val)
                  17 (println (deref liked-values))
                  :else nil)
                0 nil))
            ::record-value-handler)

;; determine maprange's destination high point, thus changing maprange's scale
  (on-event [:midi :control-change]
            (fn [{note :note val :velocity}]
              (cond (= note 2) (do (reset! dst-hi val)
                                   (println @dst-hi))))
            ::test-range-high)

;; determine trate
  (on-event [:midi :control-change]
            (fn [{note :note vel :velocity}]
              (cond (= note 3)
                    (do (reset! trate-ref vel)
                        (ctl gold :trate (maprange [0 127] [0.01 2] vel))
                        (println vel))))
            ::set-trate-and-play)

;; determine dur-numerator
  (on-event [:midi :control-change]
            (fn [{note :note vel :velocity}]
              (cond (= note 4)
                    (do (reset! durnumerator-ref vel)
                        (ctl gold :dur-numerator (maprange [0 127] [1 20] vel))
                        (println vel))))
            ::set-durnum-and-play)
#+END_SRC
