* preliminaries
[[id:F50F4B96-20C5-4F82-A29D-88791760D5F5][load all apollo soundfiles into overtone]]
* define synths and load samples
** new general-tgrains-synth
*** definition
#+BEGIN_SRC clojure :results silent
  (defsynth general-tgrains-synth [buffer 0 trate 1 dur-numerator 8 amp 0.8 centerpos 0]
    (let [trate trate
          dur (/ dur-numerator trate)
          clk (impulse:ar trate)
          centerpos centerpos]
      (out 0 (pan2 (t-grains:ar 1 clk buffer 1 centerpos dur 0 amp 2)))))
#+END_SRC
*** arguments comprise: buff trate dur-num amp centerpos
** sample playback versions
*** goldberg
#+BEGIN_SRC clojure
  (def goldberg-slow (load-sample "/Users/b/Google Drive/Audio_uploads/wav-file-uploads/goldberg-slow-mono.wav"))

  (def gold (general-tgrains-synth 11))
#+END_SRC

#+RESULTS:
: #'user/goldberg-slow#'user/gold
*** apollo tracks

#+BEGIN_SRC clojure :results silent
(def var1 (general-tgrains-synth 0))
#+END_SRC
*** compare general-tgrains with line-synths
[[id:326223F4-AA19-4058-A07C-3E5F5DB9AFF5][use lines and scaling and more MIDI buttons]]

#+BEGIN_SRC clojure
(def var1-line (tgrains-line-synth :buffer 0 :mult 1))
#+END_SRC

#+RESULTS:
: #'user/var1-line

#+BEGIN_SRC clojure :results silent
(ctl var1-line :amp 0.1)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(ctl var1-line :amp 0.8)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(ctl var1-line :duration-mult 1)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(ctl var1-line :dur-numerator 1)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(def var1-noline (general-tgrains-synth :buffer 0 :centerpos 1))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(ctl var1-noline :centerpos (line:kr 0 4 20 FREE))
#+END_SRC

** load all other apollo samples--see link
[[id:C99A4AE2-B22E-4F21-88B8-E64B3CC4D6E2][load all apollo soundfiles into overtone]]

* define refs
** all refs in one block
#+BEGIN_SRC clojure :results silent
;;; save "centerpos" values
  (def liked-values (atom []))

;;; use current-val to hold current 'centerpos' value
  (def current-val (atom 0))

;;; use cc knob to change high point of maprange destination value
  (def dst-hi (atom 0))

;;; determine trate value
  (def trate-ref (atom 1))

;;; determine dur-numerator for tgrains duration
  (def durnumerator-ref (atom 8))
#+END_SRC
** break down of refs
- liked-values ::
- current-val ::
- dst-hi ::
- trate-ref ::
- durnumerator-ref :: 

* define utility functions
** record-val (to 'liked-values' ref); my maprange; round2; read-ugen

#+BEGIN_SRC clojure
  ;; hard codes in ref for "liked-values"
  (defn record-val [place]
    (swap! liked-values conj (deref place)))

(defn maprange [[a1 a2] [b1 b2] s]
	(+ b1 (/ (* (- s a1) (- b2 b1)) (- a2 a1))))

(defn round2
  "Round a double to the given precision (number of significant digits)"
  [precision d]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/round (* d factor)) factor)))

(defmacro read-ugen [dur ugen]
`(run ~dur (poll:kr (impulse:kr 2) ~ugen)))
#+END_SRC

#+RESULTS:
: #'user/record-val#'user/maprange#'user/read-ugen

* define event handlers
** event handler pad and knob abstractions
See [[id:B859EFB9-72F9-405E-9E1F-A0BF75022781][Set four knobs for amp and centerpos across goldberg and yancey]]
for examples of how to use reset-knob and swap-pad
#+BEGIN_SRC clojure :results silent
  (defn old-reset-knob [synth synth-param knob-number place midi-channel & {:keys [scale]
                                                                        :or {scale 1}}]
      (fn [{knob :note val :velocity chan :channel}]
        (if (= chan midi-channel)
          (cond (= knob knob-number)
                (do (reset! place (* val scale))
                    (ctl synth (keyword synth-param) (deref place))
                    (println (str synth-param knob-number " : ") (deref place)))))))

  (defn old-swap-pad [synth synth-param pad-number place swap-fn midi-channel]
      (fn [{pad :note val :velocity chan :channel}]
        (if (= chan midi-channel)
          (cond (= pad pad-number)
                (do (swap! place swap-fn)
                    (ctl synth (keyword synth-param) (deref place))
                    (println (str synth-param pad-number " : ") (deref place)))))))
#+END_SRC
** keyboard keys and transport event handlers, with scaling (hard codes synth!)
:PROPERTIES:
:ID:       5B64A0AA-C2B5-468A-A39F-4DC5D3EF55D0
:END:
#+BEGIN_SRC clojure
;; determine "centerpos" based on MIDI keyboard notes
  (on-event [:midi :note-on]
            (fn [{note :note}]
              (let [val (deref current-val)]
                (do (reset! current-val (maprange [60 91] [0.0 @dst-hi] note))
                    (ctl gold :centerpos val)
                    (println (round2 val 2)))))
            ::set-current-val-scale-and-play)

;; save a "liked value" into storage with "record" button
;; return list of "liked values" with "play" button
  (on-event [:midi :control-change]
            (fn [{cc-channel :note vel :velocity}]
              (case vel
                127
                (case cc-channel 
                  18 (record-val current-val)
                  17 (println (deref liked-values))
                  :else nil)
                0 nil))
            ::record-value-handler)

;; determine maprange's destination high point, thus changing maprange's scale
  (on-event [:midi :control-change]
            (fn [{note :note val :velocity}]
              (cond (= note 2) (do (reset! dst-hi val)
                                   (println @dst-hi))))
            ::test-range-high)

;; determine trate
  (on-event [:midi :control-change]
            (fn [{note :note vel :velocity}]
              (cond (= note 3)
                    (do (reset! trate-ref vel)
                        (ctl gold :trate (maprange [0 127] [0.01 2] vel))
                        (println vel))))
            ::set-trate-and-play)

;; determine dur-numerator
  (on-event [:midi :control-change]
            (fn [{note :note vel :velocity}]
              (cond (= note 4)
                    (do (reset! durnumerator-ref vel)
                        (ctl gold :dur-numerator (maprange [0 127] [1 20] vel))
                        (println vel))))
            ::set-durnum-and-play)
#+END_SRC

#+RESULTS:
: :added-async-handler:added-async-handler

#+BEGIN_SRC clojure :results silent
(remove-event-handler ::test-range-high)
#+END_SRC
* refactor event handlers!
** TODO for refactoring keyboard and CC event-handlers
- to take synth ugen as argument--must be a macro??
- print out message with value to STOUT
- fix "no matching clause" errors for (15,
- be able to add and remove event-handlers more gracefully
** MASTER CONTROL-CHANGE EVENT HANDLER needed!
#+BEGIN_SRC clojure
;; save a "liked value" into storage with "record" button
;; return list of "liked values" with "play" button
  (on-event [:midi :control-change]
            (fn [{cc-channel :note vel :velocity}]
              (case vel
                127
                (case cc-channel 
                  18 (record-val current-val)
                  17 (println (deref liked-values))
                  :else nil)
                0 nil))
            ::record-value-handler)

;; determine maprange's destination high point, thus changing maprange's scale


#+END_SRC

#+RESULTS:
: :added-async-handler:added-async-handler

* note-on ON-EVENTER (note-on event handler for any active synth)
#+BEGIN_SRC clojure :results silent
;; determine "centerpos" based on MIDI keyboard notes
(defn on-eventer [active-synth handler-double-colon-name]
  (on-event [:midi :note-on]
            (fn [{note :note}]
              (let [val (deref current-val)]
                (do (reset! current-val (maprange [60 91] [0.0 @dst-hi] note))
                    (ctl active-synth :centerpos val)
                    (println (str "centerpos (via dst-hi): " (round2 val 2))))))
            handler-double-colon-name))



#+END_SRC

#+BEGIN_SRC clojure :results silent
(def var1-noline (general-tgrains-synth :buffer 0 :centerpos 1))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(def var2-noline (general-tgrains-synth :buffer 1 :centerpos 1))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(on-eventer var2-noline ::no-liner)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(remove-event-handler ::no-liner)
#+END_SRC

* cc-change ON-EVENTER
#+BEGIN_SRC clojure :results silent
(defn cc-on-eventer [a-ref knob-num double-colon-name]
(on-event [:midi :control-change]
            (fn [{note :note val :velocity}]
              (cond (= note knob-num) 
              (do (reset! a-ref val)
                                   (println (str double-colon-name ": " (deref a-ref))))))
double-colon-name))
#+END_SRC

#+BEGIN_SRC clojure :results silent
(cc-on-eventer dst-hi 3 ::dst-hi-change)
#+END_SRC

#+BEGIN_SRC clojure :results silent
(remove-event-handler ::dst-hi-change)
#+END_SRC
